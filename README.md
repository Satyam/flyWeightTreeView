flyWeightTreeView
=================

An implementation of a YUI3 TreeView based on the FlyWeight pattern.

Ok, the name might not be the best and my implementation of the pattern not accurate, but it works like this.

The data of the tree is held in a plain object without methods, attributes or events.  Usually it is the very same object as provided as its initial configuration, for example:
``` Javascript
[
	{
		label:'label 0',
		children: [
			{
				label: 'label 0-0',
				expanded: false,
				children: [
					{
						label: 'label 0-0-0'
					},
					{
						label: 'label 0-0-1'
					}
				]
			},
			{
				label: 'label 0-1'
			}
		]
	},
	{
		label: 'label 1'
	}

]
```
For safety reasons, the tree configuration is cloned into an internal private property so changes in one do not affect the other.  The internal copy is traversed and extra information added to each node, such as `parent` links to aid in navigation.  Over the lifetime of the application, the internal copy will be augmented with further information.

In order to simplyfy the explanation, I will refer to TreeView and TreeNode instances though the explanation applies as well to a component made of Menu and MenuItem objects or Form and InputField objects.   The TreeView is the manager, the TreeNode is the node-object instance.

The TreeNode contains all the functionality for each node.  While the internal configuration object has all the data, it has no methods, attributes or events.  It is the TreeNode (the node-object instance) that has the behaviour.
 
The TreeView (the manager object) has a pool of TreeNodes objects.   If a node does not have a `type` property, they will be of the default type set in the manager (for TreeView that would be TreeNode).   TreeView contains separate pools per type so an object of the appropriate class is always available. If a pool has no instances of a given type, a newly created one is returned instead.  For TreeView, the default type is TreeNode, but the `type` property might refer to a sub-class of TreeNode.

Methods `_poolFetch` and `_poolReturn` handle the pool of node-object instances. It is the responsibility of each method to return every object back to the pool once used.  However, should the developer need to retain a TreeNode instance, there is no need to return it to the pool, the manager does not keep track of the instances it delivers so it doesn't miss those not returned. The pools are never exhausted, on request, the manager will return fresh copies.

An `_slideTo`  method is available to slide a TreeNode instance on top of any node in the internal configuration tree. All modifications to the tree happen through a TreeNode instance (for performance reasons, the manager does take some shortcuts and modifies the tree directly).

For example, in the render operation, TreeView calls the `_getHTML` method on the root node. The root node does not have a visual representation of its own, only of its children.   Thus, it loops through each of its children were each returns the representation of itself plus that generated by its children.  That HTML is produced by filling up the node template with the information on each node as returned by a call to `getAttrs`.  It is the TreeView that finally inserts the string with all the markup into the ContentBox. TreeNodes are subclasses of Y.Base, TreeView is the only subclass of Y.Widget.

Looping over the children of a node is done via the `forEachChild` method, which will fetch a TreeNode instance from the pool, slide it on top of each node and call the provided callback method and return the node instance to the pool. The reason to return it to the pool is that the next node might be of a different type, however, there is space for optimization there.

Events are handled by delegation by TreeView. When an event is detected, TreeView locates the internal node that corresponds to the target, fetches a TreeNode (or the node-object instance according to the type), slides it on top of that internal node and fires a custom event on TreeNode.  
Here I must set the manager apart from TreeView, which is a subclass of it.  The manager itself listens to no events.  It is each of its subclasses, such as TreeView, that decides what events it cares to listen to and then send to each node-instance object to handle (such as TreeNode).
The event listener on TreeNode needs not be aware of all this.  By the time it responded to the event, the TreeNode has already been positioned on top of the corresponding internal configuration node and it doesn't need to do anything when it is done, the TreeNode instance will be returned to the pool by the manager when it returns from firing the event.

All attribute change events work normally, after all, to change an attribute you have to do it through a TreeNode instance which is already positioned over the internal node so it will listen to the attribute-change event it has just generated.
Of course, if an internal-node property is changed directly, no TreeNode will ever know so the developer should not do this.

If the developer needs to keep a reference to a TreeNode instance such as those provided by the callback of `forEachChild` or to an event listener, for example, to do an asynchronous operation, the developer should call the `hold` method.  Normally, those are temporary copies and are returned to the pool once the callback is finished. If a reference is kept without telling the manager (TreeView) to hold it, the TreeNode might be positioned elsewhere by the time it is used. Once the `hold` method is called, that instance won't go back to the pool.  To free it, you must call the `release`method.  Once an instance is released, its reference must be considered invalid, just as if it had been destroyed (in fact, it will be returned to the pool and might be repositioned).  When the pool gets a request for an instance of a node that is held, it will return a reference to the same copy held instead of another one from the pool.  If everything goes right, there should never be two active node-object instances on the same internal node.

With all nodes of the same type, the pool in the manager will contain no more than the depth of the tree, if all nodes are rendered and none has been retained (not returned).  Thus, the memory footprint is very low.

TreeNode has two type of attributes, those that are global, such as `'root'` and those that are dependent on the internal configuration object.  The developer of subclasses of the node-object classes such as TreeNode should be careful to handle them differently.  The regular attributes will not change when TreeNode is slid on top of a node.  Node-dependent attributes need getters and setters to look for the value in the internal configuration object.  TreeNode has both a generic getter and setter that do this.  For node-dependent attributes, the `valueFn` attribute setting does not work.

---------------------------
The original proposal is described in these posts:

http://yuilibrary.com/forum/viewtopic.php?p=33740#p33740

http://yuilibrary.com/forum/viewtopic.php?p=33743#p33743

---------------------------
This demo also contains a sample on how to use this same mechanism to create a form, form fields and group of fields

------------------------------
The demo is self-contained except for the YUI files that it downloads from the internet.  You just need to browse the index.html file to see it working.

It can be seen running here:

http://satyam.com.ar/yui/3.0.0/flyWeightTreeView/

And the API docs here:

http://satyam.com.ar/yui/3.0.0/flyWeightTreeView/out